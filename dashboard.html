<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kaspa Surf — Dashboard</title>
  <style>
    :root{
      --bg:#0a0f1a; --panel:#121a2a; --panel2:#1c2333;
      --text:#e0e0e0; --muted:#aab3c5; --accent:#00b4d8; --link:#00d4ff;
      --ok:#4ade80; --bad:#ff5c5c;
      --r:14px;
    }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:linear-gradient(135deg,var(--bg),var(--panel2));color:var(--text);}
    header{padding:16px 18px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;}
    h1{margin:0;font-size:18px;letter-spacing:.2px}
    a{color:var(--link);text-decoration:none}
    a:hover{text-decoration:underline}
    main{padding:0 18px 22px;max-width:1400px;margin:0 auto;}
    .card{background:rgba(18,26,42,.82);border:1px solid rgba(255,255,255,.06);border-radius:var(--r);padding:14px;box-shadow:0 10px 30px rgba(0,0,0,.25);margin-top:12px;}
    .card h2{margin:0 0 10px;font-size:13px;color:var(--muted);font-weight:650;display:flex;align-items:center;justify-content:space-between;gap:10px}
    .status{font-size:12px;color:var(--muted)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .bad{color:var(--bad)} .ok{color:var(--ok)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}

    .grid{display:grid; gap:12px; grid-template-columns:repeat(12, minmax(0, 1fr)); margin-top:12px;}
    .span-4{grid-column:span 4}
    .span-8{grid-column:span 8}
    .span-6{grid-column:span 6}
    @media (max-width: 1100px){ .span-4,.span-6,.span-8{grid-column:span 12} }

    .kvs{display:grid;gap:10px;grid-template-columns:repeat(2,minmax(0,1fr));margin-top:10px;}
    .kv{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.06);border-radius:12px;padding:10px;}
    .kv .k{font-size:11px;color:var(--muted)}
    .kv .v{font-size:16px;margin-top:4px;font-weight:800}
    .kv .s{font-size:12px;margin-top:4px;color:var(--muted)}

    table{width:100%;border-collapse:collapse;font-size:12px}
    th,td{padding:10px 8px;border-bottom:1px solid rgba(255,255,255,.07);vertical-align:top}
    th{color:var(--muted);font-weight:650;text-align:left}

    .btn{
      background:rgba(255,255,255,.05);color:var(--text);border:1px solid rgba(0,180,216,.35);
      padding:8px 10px;border-radius:12px;cursor:pointer;
    }
    .btn:hover{background:rgba(0,180,216,.10)}
    .nowrap{white-space:nowrap}

    .toggle{
      display:inline-flex;gap:8px;align-items:center;
      padding:6px 10px;border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      user-select:none;
    }
    .toggle input{accent-color: var(--accent);}

    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    input{
      background:rgba(255,255,255,.05);color:var(--text);border:1px solid rgba(255,255,255,.10);
      padding:10px 12px;border-radius:12px;outline:none;
    }

    /* sparkline */
    .sparkWrap{
      margin-top:10px;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.06);
      border-radius:12px;
      padding:10px;
    }
    svg{display:block;width:100%;height:56px}
    .sparkAxis{opacity:.6;font-size:10px;fill:var(--muted)}
  </style>
</head>

<body>
<header>
  <div class="row">
    <h1>Kaspa Surf — Dashboard</h1>
    <span class="status">· <a href="address.html">Address Explorer</a></span>
  </div>

  <div class="row">
    <span class="status">REST: <a id="restLink" href="#" target="_blank" rel="noreferrer">rest-api.kaspa.surf</a></span>
    <span class="status">·</span>
    <span class="status">Last refresh: <span id="last" class="mono">—</span></span>

    <label class="toggle status" title="Auto refresh">
      <input type="checkbox" id="auto" checked />
      Auto
    </label>

    <button class="btn" id="refreshBtn">Refresh</button>
  </div>
</header>

<main>
  <div class="grid">
    <!-- Market -->
    <section class="card span-4">
      <h2>
        Market (self-hosted)
        <span class="status" id="marketMeta">—</span>
      </h2>

      <div class="kvs" id="marketKvs"></div>

      <div class="sparkWrap">
        <div class="status">Price sparkline</div>
        <svg id="spark" viewBox="0 0 300 56" preserveAspectRatio="none" aria-label="price sparkline">
          <polyline id="sparkLine" fill="none" stroke="currentColor" stroke-width="2" points=""></polyline>
          <text id="sparkMin" class="sparkAxis" x="2" y="52"></text>
          <text id="sparkMax" class="sparkAxis" x="2" y="12"></text>
        </svg>
      </div>

      <div class="status" id="marketErr"></div>
    </section>

    <!-- Network -->
    <section class="card span-8">
      <h2>
        Network / Node (self-hosted)
        <span class="status" id="netMeta">—</span>
      </h2>
      <div class="kvs" id="netKvs"></div>
      <div class="status" id="netErr"></div>
    </section>

    <!-- Blocks -->
    <section class="card span-6">
      <h2>
        Latest Blocks (self-hosted)
        <span class="status" id="blocksMeta">—</span>
      </h2>
      <div style="overflow:auto">
        <table>
          <thead>
            <tr>
              <th class="nowrap">Time</th>
              <th>Hash</th>
              <th class="nowrap">Blue score</th>
              <th class="nowrap">Txs</th>
            </tr>
          </thead>
          <tbody id="blocksBody"></tbody>
        </table>
      </div>
      <div class="status" id="blocksErr"></div>
    </section>

    <!-- Txs -->
    <section class="card span-6">
      <h2>
        Latest Transactions (self-hosted)
        <span class="status" id="txMeta">—</span>
      </h2>

      <div class="controls" style="margin:8px 0 10px">
        <input id="txSearch" class="mono" style="flex:1;min-width:280px" placeholder="Search TxID (paste full txid)"/>
        <button class="btn" id="txGo">Search</button>
        <span class="status" id="txSearchMsg">—</span>
      </div>

      <div style="overflow:auto">
        <table>
          <thead>
            <tr>
              <th class="nowrap">Time</th>
              <th>TxID</th>
              <th class="nowrap">Inputs</th>
              <th class="nowrap">Outputs</th>
            </tr>
          </thead>
          <tbody id="txBody"></tbody>
        </table>
      </div>
      <div class="status" id="txErr"></div>
    </section>
  </div>
</main>

<script>
  // ================== CONFIG ==================
  // Everything below uses ONLY your working REST server.
  const REST_BASE = "https://rest-api.kaspa.surf";

  const REFRESH_MS = 15000;
  const $ = (id) => document.getElementById(id);

  $("restLink").href = REST_BASE;
  $("restLink").textContent = REST_BASE.replace("https://","");

  // ================== HELPERS ==================
  const isDigits = (s) => typeof s === "string" && /^[0-9]+$/.test(s);

  const toNumberMaybe = (v) => {
    if (v == null) return null;
    if (typeof v === "number") return v;
    if (isDigits(v)) return Number(v);
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  };

  const fmtNum = (n, maxFrac=8) => {
    if (n === null || n === undefined || n === "") return "—";
    const x = toNumberMaybe(n);
    if (x === null) return String(n);
    return x.toLocaleString(undefined, { maximumFractionDigits: maxFrac });
  };

  const fmtDate = (msOrIso) => {
    if (!msOrIso && msOrIso !== 0) return "—";
    const v = isDigits(msOrIso) ? Number(msOrIso) : msOrIso;
    const d = typeof v === "number" ? new Date(v) : new Date(v);
    return isNaN(d.getTime()) ? String(msOrIso) : d.toLocaleString();
  };

  const shortHash = (s, n=18) => (s ? (String(s).slice(0,n) + "…") : "—");

  async function fetchWithTimeout(url, opts={}, timeoutMs=9000){
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try{
      const res = await fetch(url, { ...opts, signal: ctrl.signal });
      return res;
    } finally { clearTimeout(t); }
  }

  async function getJson(path, opts={}){
    const res = await fetchWithTimeout(REST_BASE + path, {
      ...opts,
      headers: { "accept":"application/json", ...(opts.headers||{}) }
    });
    if (!res.ok) {
      const txt = await res.text().catch(() => "");
      throw new Error(`${res.status} ${res.statusText}${txt ? ` · ${txt.slice(0,160)}` : ""}`);
    }
    const ct = res.headers.get("content-type") || "";
    if (!ct.includes("application/json")) return await res.text();
    return await res.json();
  }

  async function postJson(path, body){
    return await getJson(path, {
      method: "POST",
      headers: { "content-type":"application/json" },
      body: JSON.stringify(body)
    });
  }

  function kvGrid(el, items){
    el.innerHTML = items.map(({k,v,s}) => `
      <div class="kv">
        <div class="k">${k}</div>
        <div class="v">${v}</div>
        ${s ? `<div class="s">${s}</div>` : ``}
      </div>
    `).join("");
  }

  // ================== SPARKLINE ==================
  const PRICE_HISTORY = [];
  const PRICE_HISTORY_MAX = 80;

  function drawSparkline(){
    const line = $("sparkLine");
    const tMin = $("sparkMin");
    const tMax = $("sparkMax");

    if (PRICE_HISTORY.length < 2){
      line.setAttribute("points", "");
      tMin.textContent = "";
      tMax.textContent = "";
      return;
    }

    const w = 300, h = 56, padTop = 6, padBottom = 8;
    const vals = PRICE_HISTORY.slice(-PRICE_HISTORY_MAX);
    const min = Math.min(...vals);
    const max = Math.max(...vals);
    const span = (max - min) || 1;

    const pts = vals.map((v, i) => {
      const x = (i / (vals.length - 1)) * w;
      const y = padTop + (1 - (v - min) / span) * (h - padTop - padBottom);
      return `${x.toFixed(2)},${y.toFixed(2)}`;
    }).join(" ");

    line.setAttribute("points", pts);
    line.style.color = "var(--accent)";
    tMin.textContent = `$${min.toFixed(4)}`;
    tMax.textContent = `$${max.toFixed(4)}`;
  }

  // ================== MARKET (REST) ==================
  async function loadMarket(){
    $("marketErr").textContent = "";
    $("marketMeta").textContent = "—";

    kvGrid($("marketKvs"), [
      {k:"Price (USD)", v:"—"},
      {k:"Marketcap", v:"—"},
      {k:"Hashrate (TH/s)", v:"—"},
      {k:"Block reward", v:"—"},
      {k:"Fee estimate", v:"—"},
    ]);

    try{
      const [price, marketcap, hashrate, reward, fee] = await Promise.allSettled([
        getJson("/info/price"),
        getJson("/info/marketcap"),
        getJson("/info/hashrate"),
        getJson("/info/blockreward"),
        getJson("/info/fee-estimate"),
      ]);

      const priceObj = price.status === "fulfilled" ? price.value : null;
      const marketObj = marketcap.status === "fulfilled" ? marketcap.value : null;
      const hashrObj = hashrate.status === "fulfilled" ? hashrate.value : null;
      const rewardObj = reward.status === "fulfilled" ? reward.value : null;
      const feeObj = fee.status === "fulfilled" ? fee.value : null;

      const last = toNumberMaybe(priceObj?.price) ?? toNumberMaybe(marketObj?.price);
      if (last != null){
        PRICE_HISTORY.push(last);
        while (PRICE_HISTORY.length > PRICE_HISTORY_MAX) PRICE_HISTORY.shift();
        drawSparkline();
      }

      const mcap = toNumberMaybe(marketObj?.marketcap);
      const hr = toNumberMaybe(hashrObj?.hashrate); // spec says TH/s
      const br = toNumberMaybe(rewardObj?.blockreward);
      const prio = feeObj?.priorityBucket?.feerate ?? null;

      kvGrid($("marketKvs"), [
        {k:"Price (USD)", v: last==null ? "—" : `$${fmtNum(last, 6)}`, s: "source: rest-api /info/price"},
        {k:"Marketcap", v: mcap==null ? "—" : fmtNum(mcap, 0), s: "source: rest-api /info/marketcap (via coingecko)"},
        {k:"Hashrate (TH/s)", v: hr==null ? "—" : fmtNum(hr, 2), s: "source: rest-api /info/hashrate"},
        {k:"Block reward", v: br==null ? "—" : fmtNum(br, 0), s: "KAS/block (as reported)"},
        {k:"Fee estimate", v: prio==null ? "—" : `${fmtNum(prio, 0)} sompi/gram`, s: "priority bucket"},
      ]);

      $("marketMeta").textContent = "REST endpoints: /info/price + /info/marketcap + /info/hashrate";
    } catch(e){
      $("marketErr").innerHTML = `<span class="bad">${String(e.message || e)}</span>`;
      $("marketMeta").textContent = "—";
    }
  }

  // ================== BLOCKS (REST) ==================
  let LAST_BLOCKS = [];

  function normalizeRestBlocks(resp){
    // /blocks returns { blockHashes:[], blocks:[] } per your OpenAPI
    const blocks = Array.isArray(resp?.blocks) ? resp.blocks : (Array.isArray(resp) ? resp : []);
    return blocks;
  }

  function blockTimeMs(b){
    // many fields are strings in the OpenAPI
    const t =
      b?.header?.timestamp ??
      b?.verboseData?.timestamp ??
      b?.verboseData?.blockTime ??
      b?.timestamp ??
      null;
    const n = toNumberMaybe(t);
    return n == null ? null : n;
  }

  function blockHash(b){
    return (
      b?.header?.hash ??
      b?.hash ??
      b?.verboseData?.hash ??
      b?.id ??
      "—"
    );
  }

  function blockBlueScore(b){
    return (
      b?.verboseData?.blueScore ??
      b?.header?.blueScore ??
      b?.blueScore ??
      b?.blue_score ??
      null
    );
  }

  function blockTxCount(b){
    if (Array.isArray(b?.transactions)) return b.transactions.length;
    // sometimes REST blocks list only hashes unless includeTransactions=true
    return null;
  }

  async function loadBlocks(){
    $("blocksErr").textContent = "";
    $("blocksMeta").textContent = "—";
    $("blocksBody").innerHTML = `<tr><td colspan="4" class="status">Loading…</td></tr>`;

    try{
      const dag = await getJson("/info/blockdag");
      const lowHash = dag?.sink || dag?.pruningPointHash;
      if (!lowHash) throw new Error("No sink/pruningPointHash from /info/blockdag");

      const resp = await getJson(`/blocks?lowHash=${encodeURIComponent(lowHash)}&includeBlocks=true&includeTransactions=false`);
      const blocks = normalizeRestBlocks(resp);

      LAST_BLOCKS = blocks.slice(0, 60);

      if (!blocks.length){
        $("blocksBody").innerHTML = `<tr><td colspan="4" class="status">No blocks returned.</td></tr>`;
        $("blocksMeta").textContent = `REST: /blocks (0)`;
        return;
      }

      $("blocksMeta").textContent = `REST: /blocks · showing ${Math.min(20, blocks.length)}`;

      $("blocksBody").innerHTML = blocks.slice(0,20).map(b => {
        const hash = blockHash(b);
        const time = blockTimeMs(b);
        const score = blockBlueScore(b);
        const txs = blockTxCount(b);

        const hashCell = `<span class="mono" title="${hash}">${shortHash(hash, 24)}</span>`;

        return `<tr>
          <td class="nowrap">${fmtDate(time)}</td>
          <td>${hashCell}</td>
          <td class="nowrap">${score==null ? "—" : fmtNum(score,0)}</td>
          <td class="nowrap">${txs==null ? "—" : fmtNum(txs,0)}</td>
        </tr>`;
      }).join("");
    } catch(e){
      $("blocksBody").innerHTML = `<tr><td colspan="4" class="status">Failed to load blocks.</td></tr>`;
      $("blocksErr").innerHTML = `<span class="bad">${String(e.message || e)}</span>`;
    }
  }

  function computeBlockRateFromBlocks(){
    const blocks = LAST_BLOCKS || [];
    if (blocks.length < 12) return null;

    const times = blocks
      .map(blockTimeMs)
      .filter(v => v != null && Number.isFinite(v));

    if (times.length < 12) return null;

    // blocks are newest first; compute avg interval using first N
    const n = Math.min(20, times.length - 1);
    const newest = times[0];
    const oldest = times[n];
    const dt = newest - oldest;
    if (dt <= 0) return null;

    const avgIntervalSec = (dt / 1000) / n;
    if (avgIntervalSec <= 0) return null;
    return 1 / avgIntervalSec;
  }

  // ================== TXs (REST) ==================
  // We'll show "latest-ish" txs by reading virtual-chain blocks and flattening txs.
  function extractTxsFromVc(vcs){
    // vcs is array of VcBlockModel; each has {timestamp, blue_score, transactions:[...]}
    const out = [];
    for (const b of (Array.isArray(vcs) ? vcs : [])){
      const tms = toNumberMaybe(b?.timestamp);
      const txs = Array.isArray(b?.transactions) ? b.transactions : [];
      for (const tx of txs){
        out.push({
          time: tms,
          txid: tx?.transaction_id ?? tx?.transactionId ?? tx?.id ?? null,
          vin: Array.isArray(tx?.inputs) ? tx.inputs.length : null,
          vout: Array.isArray(tx?.outputs) ? tx.outputs.length : null,
        });
      }
    }
    // newest first
    out.sort((a,b) => (b.time||0) - (a.time||0));
    return out;
  }

  async function fetchTxDetails(txid){
    try{
      // REST supports details here
      return await getJson(`/transactions/${encodeURIComponent(txid)}?inputs=true&outputs=true&resolve_previous_outpoints=light`);
    } catch(e){
      return null;
    }
  }

  async function loadTxs(){
    $("txErr").textContent = "";
    $("txMeta").textContent = "—";
    $("txBody").innerHTML = `<tr><td colspan="4" class="status">Loading…</td></tr>`;

    try{
      const score = await getJson("/info/virtual-chain-blue-score");
      const bs = toNumberMaybe(score?.blueScore);
      if (bs == null) throw new Error("No blueScore from /info/virtual-chain-blue-score");

      // Must be divisible by limit (your OpenAPI says). We'll use limit=10.
      const limit = 10;
      const gte = Math.max(0, bs - 1000);
      const gteAdj = gte - (gte % limit);

      const vcs = await getJson(`/virtual-chain?blueScoreGte=${gteAdj}&limit=${limit}&resolveInputs=false&includeCoinbase=true`);
      const flat = extractTxsFromVc(vcs).slice(0, 20);

      if (!flat.length){
        $("txBody").innerHTML = `<tr><td colspan="4" class="status">No transactions returned.</td></tr>`;
        $("txMeta").textContent = `REST: /virtual-chain (0)`;
        return;
      }

      $("txMeta").textContent = `REST: /virtual-chain · showing ${flat.length}`;

      $("txBody").innerHTML = flat.map(t => `
        <tr data-txid="${t.txid || ""}">
          <td class="nowrap">${fmtDate(t.time)}</td>
          <td class="mono" title="${t.txid || "—"}">${t.txid ? shortHash(t.txid, 28) : "—"}</td>
          <td class="nowrap">${t.vin==null ? "—" : fmtNum(t.vin,0)}</td>
          <td class="nowrap">${t.vout==null ? "—" : fmtNum(t.vout,0)}</td>
        </tr>
      `).join("");
    } catch(e){
      $("txBody").innerHTML = `<tr><td colspan="4" class="status">Failed to load transactions.</td></tr>`;
      $("txErr").innerHTML = `<span class="bad">${String(e.message || e)}</span>`;
    }
  }

  async function searchTx(){
    const q = $("txSearch").value.trim();
    $("txSearchMsg").textContent = "—";
    if (!q){
      $("txSearchMsg").innerHTML = `<span class="bad">Paste a TxID.</span>`;
      return;
    }
    $("txSearchMsg").textContent = "Searching…";

    const detail = await fetchTxDetails(q);
    if (!detail){
      $("txSearchMsg").innerHTML = `<span class="bad">Not found</span>`;
      return;
    }

    // REST TxModel uses transaction_id + block_time fields
    const txid = detail?.transaction_id ?? detail?.transactionId ?? detail?.txid ?? q;
    const time = toNumberMaybe(detail?.block_time) ?? toNumberMaybe(detail?.blockTime) ?? null;
    const vin = Array.isArray(detail?.inputs) ? detail.inputs.length : null;
    const vout = Array.isArray(detail?.outputs) ? detail.outputs.length : null;

    $("txSearchMsg").innerHTML = `<span class="ok">Found</span> · ${shortHash(txid, 20)} · ${fmtDate(time)}`;

    const tr = `
      <tr>
        <td class="nowrap">${fmtDate(time)}</td>
        <td class="mono" title="${txid}">${shortHash(txid, 28)}</td>
        <td class="nowrap">${vin==null ? "—" : fmtNum(vin,0)}</td>
        <td class="nowrap">${vout==null ? "—" : fmtNum(vout,0)}</td>
      </tr>
    `;
    $("txBody").insertAdjacentHTML("afterbegin", tr);
  }

  $("txGo").onclick = searchTx;
  $("txSearch").addEventListener("keydown", (e) => { if (e.key === "Enter") searchTx(); });

  // ================== NETWORK (REST) ==================
  async function loadNetwork(){
    $("netErr").textContent = "";
    $("netMeta").textContent = "—";

    kvGrid($("netKvs"), [
      {k:"Network", v:"—"},
      {k:"Block rate", v:"—"},
      {k:"Difficulty", v:"—"},
      {k:"Hashrate (TH/s)", v:"—"},
      {k:"Blue score", v:"—"},
      {k:"Node sync", v:"—"},
    ]);

    try{
      const [dag, score, kaspad, hashr] = await Promise.all([
        getJson("/info/blockdag"),
        getJson("/info/virtual-chain-blue-score"),
        getJson("/info/kaspad"),
        getJson("/info/hashrate"),
      ]);

      const network = dag?.networkName ?? dag?.network ?? "kaspa-mainnet";
      const diff = dag?.difficulty ?? null;
      const blue = toNumberMaybe(score?.blueScore);
      const hr = toNumberMaybe(hashr?.hashrate);

      const isSynced = kaspad?.isSynced;
      const syncTxt = (typeof isSynced !== "boolean")
        ? "—"
        : (isSynced ? `<span class="ok">Synced</span>` : `<span class="bad">Syncing</span>`);

      const bps = computeBlockRateFromBlocks();

      kvGrid($("netKvs"), [
        {k:"Network", v: network},
        {k:"Block rate", v: bps==null ? "—" : `${fmtNum(bps, 3)} /s`, s: bps==null ? "" : "computed from /blocks timestamps"},
        {k:"Difficulty", v: diff==null ? "—" : fmtNum(diff, 0)},
        {k:"Hashrate (TH/s)", v: hr==null ? "—" : fmtNum(hr, 2)},
        {k:"Blue score", v: blue==null ? "—" : fmtNum(blue, 0)},
        {k:"Node sync", v: syncTxt, s: "from /info/kaspad"},
      ]);

      $("netMeta").textContent = "REST: /info/blockdag · /info/kaspad · /info/hashrate · /info/virtual-chain-blue-score";
    } catch(e){
      $("netErr").innerHTML = `<span class="bad">${String(e.message || e)}</span>`;
    }
  }

  // ================== REFRESH LOOP ==================
  let refreshing = false;

  async function refreshAll(){
    $("last").textContent = new Date().toLocaleTimeString();

    // Order matters: blocks first so network can compute bps
    await loadBlocks();
    await Promise.allSettled([
      loadMarket(),
      loadNetwork(),
      loadTxs(),
    ]);
  }

  async function loop(){
    if (refreshing) return;
    refreshing = true;
    try { await refreshAll(); }
    finally {
      refreshing = false;
      if ($("auto").checked) setTimeout(loop, REFRESH_MS);
    }
  }

  $("refreshBtn").onclick = () => refreshAll();
  $("auto").onchange = () => { if ($("auto").checked) loop(); };

  // Start
  loop();
</script>
</body>
</html>
