<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kaspa Surf — Dashboard</title>
  <style>
    :root{
      --bg:#0a0f1a; --panel:#121a2a; --panel2:#1c2333;
      --text:#e0e0e0; --muted:#aab3c5; --accent:#00b4d8; --link:#00d4ff;
      --ok:#4ade80; --bad:#ff5c5c;
      --r:14px;
    }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:linear-gradient(135deg,var(--bg),var(--panel2));color:var(--text);}
    header{padding:16px 18px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;}
    h1{margin:0;font-size:18px;letter-spacing:.2px}
    a{color:var(--link);text-decoration:none}
    a:hover{text-decoration:underline}
    main{padding:0 18px 22px;max-width:1400px;margin:0 auto;}
    .card{background:rgba(18,26,42,.82);border:1px solid rgba(255,255,255,.06);border-radius:var(--r);padding:14px;box-shadow:0 10px 30px rgba(0,0,0,.25);margin-top:12px;}
    .card h2{margin:0 0 10px;font-size:13px;color:var(--muted);font-weight:650;display:flex;align-items:center;justify-content:space-between;gap:10px}
    .status{font-size:12px;color:var(--muted)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .bad{color:var(--bad)} .ok{color:var(--ok)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}

    .grid{
      display:grid; gap:12px;
      grid-template-columns:repeat(12, minmax(0, 1fr));
      margin-top:12px;
    }
    .span-3{grid-column:span 3}
    .span-4{grid-column:span 4}
    .span-5{grid-column:span 5}
    .span-6{grid-column:span 6}
    .span-7{grid-column:span 7}
    .span-8{grid-column:span 8}
    .span-12{grid-column:span 12}
    @media (max-width: 1100px){
      .span-3,.span-4,.span-5,.span-6,.span-7,.span-8{grid-column:span 12}
    }

    .kvs{display:grid;gap:10px;grid-template-columns:repeat(2,minmax(0,1fr));margin-top:10px;}
    .kv{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.06);border-radius:12px;padding:10px;}
    .kv .k{font-size:11px;color:var(--muted)}
    .kv .v{font-size:16px;margin-top:4px;font-weight:800}
    .kv .s{font-size:12px;margin-top:4px;color:var(--muted)}

    table{width:100%;border-collapse:collapse;font-size:12px}
    th,td{padding:10px 8px;border-bottom:1px solid rgba(255,255,255,.07);vertical-align:top}
    th{color:var(--muted);font-weight:650;text-align:left}

    .btn{
      background:rgba(255,255,255,.05);color:var(--text);border:1px solid rgba(0,180,216,.35);
      padding:8px 10px;border-radius:12px;cursor:pointer;
    }
    .btn:hover{background:rgba(0,180,216,.10)}
    .nowrap{white-space:nowrap}

    /* tiny toggle */
    .toggle{
      display:inline-flex;gap:8px;align-items:center;
      padding:6px 10px;border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      user-select:none;
    }
    .toggle input{accent-color: var(--accent);}
  </style>
</head>

<body>
<header>
  <div class="row">
    <h1>Kaspa Surf — Dashboard</h1>
    <span class="status">· <a href="address.html">Address Explorer</a></span>
  </div>

  <div class="row">
    <span class="status">REST: <a id="apiLink" href="#" target="_blank" rel="noreferrer">rest-api.kaspa.surf</a></span>
    <span class="status">INDEXER: <a id="indexerLink" href="#" target="_blank" rel="noreferrer">indexer.kaspa.surf</a></span>
    <span class="status">·</span>
    <span class="status">Last refresh: <span id="last" class="mono">—</span></span>

    <label class="toggle status" title="Auto refresh">
      <input type="checkbox" id="auto" checked />
      Auto
    </label>

    <button class="btn" id="refreshBtn">Refresh</button>
  </div>
</header>

<main>
  <div class="grid">
    <!-- Market / Price -->
    <section class="card span-4">
      <h2>
        Market
        <span class="status" id="marketMeta">—</span>
      </h2>
      <div class="kvs" id="marketKvs"></div>
      <div class="status" id="marketErr"></div>
    </section>

    <!-- Network -->
    <section class="card span-8">
      <h2>
        Network / Node
        <span class="status" id="netMeta">—</span>
      </h2>
      <div class="kvs" id="netKvs"></div>
      <div class="status" id="netErr"></div>
    </section>

    <!-- Blocks -->
    <section class="card span-6">
      <h2>
        Latest Blocks
        <span class="status" id="blocksMeta">—</span>
      </h2>
      <div style="overflow:auto">
        <table>
          <thead>
            <tr>
              <th class="nowrap">Time</th>
              <th>Hash</th>
              <th class="nowrap">Blue score / Height</th>
              <th class="nowrap">Txs</th>
            </tr>
          </thead>
          <tbody id="blocksBody"></tbody>
        </table>
      </div>
      <div class="status" id="blocksErr"></div>
    </section>

    <!-- Txs -->
    <section class="card span-6">
      <h2>
        Latest Transactions
        <span class="status" id="txMeta">—</span>
      </h2>
      <div style="overflow:auto">
        <table>
          <thead>
            <tr>
              <th class="nowrap">Time</th>
              <th>TxID</th>
              <th class="nowrap">Inputs</th>
              <th class="nowrap">Outputs</th>
            </tr>
          </thead>
          <tbody id="txBody"></tbody>
        </table>
      </div>
      <div class="status" id="txErr"></div>
    </section>
  </div>
</main>

<script>
  // ====== CONFIG ======
  const REST_BASE   = "https://rest-api.kaspa.surf";
  const INDEXER_BASE = "https://indexer.kaspa.surf";
  const TICKER_BASE  = "https://api.kaspa.surf";

  // Make refresh feel smooth (no hard "blink")
  const REFRESH_MS = 15000;
  // Linkouts (optional)
  const STREAM_BLOCK = (hash) => `https://kaspa.stream/block/${encodeURIComponent(hash)}`;
  const STREAM_TX    = (txid) => `https://kaspa.stream/tx/${encodeURIComponent(txid)}`;

  // ====== DOM ======
  const $ = (id) => document.getElementById(id);
  $("apiLink").href = REST_BASE; $("apiLink").textContent = REST_BASE.replace("https://","");
  $("indexerLink").href = INDEXER_BASE; $("indexerLink").textContent = INDEXER_BASE.replace("https://","");

  // ====== HELPERS ======
  const fmtNum = (n, maxFrac=8) => {
    if (n === null || n === undefined || n === "") return "—";
    const x = Number(n);
    if (!Number.isFinite(x)) return String(n);
    return x.toLocaleString(undefined, { maximumFractionDigits: maxFrac });
  };
  const fmtDate = (msOrIso) => {
    if (!msOrIso) return "—";
    const d = typeof msOrIso === "number" ? new Date(msOrIso) : new Date(msOrIso);
    return isNaN(d.getTime()) ? String(msOrIso) : d.toLocaleString();
  };
  const shortHash = (s, n=18) => (s ? (String(s).slice(0,n) + "…") : "—");

  async function fetchWithTimeout(url, opts={}, timeoutMs=8000){
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try{
      const res = await fetch(url, { ...opts, signal: ctrl.signal });
      return res;
    } finally {
      clearTimeout(t);
    }
  }

  async function getJson(base, path){
    const res = await fetchWithTimeout(base + path, { headers: { "accept":"application/json" }});
    if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
    const ct = res.headers.get("content-type") || "";
    if (!ct.includes("application/json")) return await res.text();
    return await res.json();
  }

  async function firstWorkingJson(base, paths){
    for (const p of paths){
      try{
        const data = await getJson(base, p);
        return { path: p, data };
      } catch(e){ /* keep trying */ }
    }
    return null;
  }

  function kvGrid(el, items){
    el.innerHTML = items.map(({k,v,s}) => `
      <div class="kv">
        <div class="k">${k}</div>
        <div class="v">${v}</div>
        ${s ? `<div class="s">${s}</div>` : ``}
      </div>
    `).join("");
  }

  function setLoading(section){
    if (section === "blocks") $("blocksBody").innerHTML = `<tr><td colspan="4" class="status">Loading…</td></tr>`;
    if (section === "txs") $("txBody").innerHTML = `<tr><td colspan="4" class="status">Loading…</td></tr>`;
  }

  // ====== MARKET ======
  async function loadMarket(){
    $("marketErr").textContent = "";
    $("marketMeta").textContent = "—";
    kvGrid($("marketKvs"), [
      {k:"Price (USD)", v:"—"},
      {k:"24h Change", v:"—"},
      {k:"24h High", v:"—"},
      {k:"24h Low", v:"—"},
      {k:"24h Volume", v:"—"},
    ]);

    const found = await firstWorkingJson(TICKER_BASE, [
      `/v1/ticker/kaspa`,
      `/v1/ticker/KAS`,
      `/ticker/kaspa`,
    ]);

    if (!found){
      $("marketErr").innerHTML = `<span class="bad">No ticker endpoint found.</span>`;
      return;
    }

    const { path, data } = found;

    let last=null, high=null, low=null, change=null, vol=null, src="";

    if (data?.exchanges && Array.isArray(data.exchanges)){
      // choose exchange that has more fields (change/volume) if possible
      const best =
        data.exchanges.find(x => x?.last != null && x?.change_pct != null) ||
        data.exchanges.find(x => x?.last != null && x?.volume_24h != null) ||
        data.exchanges.find(x => x?.last != null) ||
        data.exchanges[0];

      last = best?.last;
      high = best?.high;
      low  = best?.low;
      change = best?.change_pct;
      vol = best?.volume_24h;
      src = best?.exchange ? `source: ${best.exchange}` : "";
    } else {
      last = data?.price ?? data?.last ?? data?.usd ?? null;
      high = data?.high_24h ?? data?.high ?? null;
      low  = data?.low_24h ?? data?.low ?? null;
      change = data?.change_24h ?? data?.change_pct ?? null;
      vol = data?.volume_24h ?? data?.volume ?? null;
    }

    const ch = (change==null) ? "—" : `${fmtNum(change, 3)}%`;
    const chClass = (change==null) ? "" : (Number(change) >= 0 ? "ok" : "bad");

    kvGrid($("marketKvs"), [
      {k:"Price (USD)", v: last==null ? "—" : `$${fmtNum(last, 6)}`, s: src},
      {k:"24h Change", v:`<span class="${chClass}">${ch}</span>`},
      {k:"24h High", v: high==null ? "—" : `$${fmtNum(high, 6)}`},
      {k:"24h Low", v: low==null ? "—" : `$${fmtNum(low, 6)}`},
      {k:"24h Volume", v: vol==null ? "—" : fmtNum(vol, 0)},
    ]);

    $("marketMeta").textContent = `Endpoint: ${path}`;
  }

  // ====== NETWORK ======
  async function loadNetwork(){
    $("netErr").textContent = "";
    $("netMeta").textContent = "—";

    kvGrid($("netKvs"), [
      {k:"Network", v:"—"},
      {k:"Block rate", v:"—"},
      {k:"Difficulty", v:"—"},
      {k:"Hashrate", v:"—"},
      {k:"Blue score / DAA", v:"—"},
      {k:"Node sync", v:"—"},
    ]);

    const netFound = await firstWorkingJson(REST_BASE, [
      `/info/network`,
      `/info`,
      `/network`,
    ]);

    const scoreFound = await firstWorkingJson(REST_BASE, [
      `/info/virtual-chain-blue-score`,
      `/info/virtual-chain-daa-score`,
    ]);

    // These may or may not exist on your build — we try anyway
    const syncFound = await firstWorkingJson(REST_BASE, [
      `/info/sync-status`,
      `/sync/status`,
      `/sync-status`,
    ]);

    const hashrateFound = await firstWorkingJson(REST_BASE, [
      `/info/hashrate`,
      `/hashrate`,
    ]);

    const bpsFound = await firstWorkingJson(REST_BASE, [
      `/info/blockrate`,
      `/blockrate`,
    ]);

    if (!netFound && !scoreFound){
      $("netErr").innerHTML = `<span class="bad">No network endpoints found.</span>`;
      return;
    }

    const net = netFound?.data || {};
    const network = net?.network ?? net?.networkName ?? net?.name ?? "Kaspa";

    const diff = net?.difficulty ?? net?.networkDifficulty ?? net?.network_difficulty ?? null;

    // score can be number or object
    const scoreData = scoreFound?.data;
    let score = "—";
    if (typeof scoreData === "number") score = fmtNum(scoreData, 0);
    else if (scoreData?.blueScore != null) score = fmtNum(scoreData.blueScore, 0);
    else if (scoreData?.daaScore != null) score = fmtNum(scoreData.daaScore, 0);
    else if (scoreData?.score != null) score = fmtNum(scoreData.score, 0);

    // sync
    const syncData = syncFound?.data;
    const sync =
      syncData?.isSynced ?? syncData?.synced ?? syncData?.is_synced ??
      syncData?.status?.isSynced ?? syncData?.status?.synced ?? null;
    const syncTxt = (sync === null) ? "—" : (sync ? `<span class="ok">Synced</span>` : `<span class="bad">Syncing</span>`);

    // hashrate
    const hrData = hashrateFound?.data;
    const hashrate =
      hrData?.hashrate ?? hrData?.networkHashrate ?? hrData?.hash_rate ??
      (typeof hrData === "number" ? hrData : null);

    // block rate
    const bpsData = bpsFound?.data;
    const bps =
      bpsData?.blockRate ?? bpsData?.bps ?? bpsData?.blocksPerSecond ??
      (typeof bpsData === "number" ? bpsData : null);

    kvGrid($("netKvs"), [
      {k:"Network", v: network},
      {k:"Block rate", v: bps==null ? "—" : `${fmtNum(bps, 3)} /s`},
      {k:"Difficulty", v: diff==null ? "—" : fmtNum(diff, 0)},
      {k:"Hashrate", v: hashrate==null ? "—" : fmtNum(hashrate, 0)},
      {k:"Blue score / DAA", v: score},
      {k:"Node sync", v: syncTxt},
    ]);

    const metaBits = [];
    if (netFound?.path) metaBits.push(`net: ${netFound.path}`);
    if (scoreFound?.path) metaBits.push(`score: ${scoreFound.path}`);
    if (syncFound?.path) metaBits.push(`sync: ${syncFound.path}`);
    if (hashrateFound?.path) metaBits.push(`hash: ${hashrateFound.path}`);
    if (bpsFound?.path) metaBits.push(`bps: ${bpsFound.path}`);
    $("netMeta").textContent = metaBits.join(" · ");
  }

  // ====== BLOCKS (INDEXER) ======
  async function loadBlocks(){
    $("blocksErr").textContent = "";
    $("blocksMeta").textContent = "—";
    setLoading("blocks");

    const found = await firstWorkingJson(INDEXER_BASE, [
      `/blocks?limit=20`,
      `/blocks?take=20`,
      `/blocks`,
    ]);

    if (!found){
      $("blocksBody").innerHTML = `<tr><td colspan="4" class="status">No blocks endpoint found.</td></tr>`;
      $("blocksErr").innerHTML = `<span class="bad">Indexer blocks endpoint not found.</span>`;
      return;
    }

    const { path, data } = found;
    const blocks = Array.isArray(data) ? data
      : Array.isArray(data?.blocks) ? data.blocks
      : Array.isArray(data?.items) ? data.items
      : [];

    if (!blocks.length){
      $("blocksBody").innerHTML = `<tr><td colspan="4" class="status">No blocks returned.</td></tr>`;
      $("blocksMeta").textContent = `Endpoint: ${path}`;
      return;
    }

    $("blocksMeta").textContent = `Endpoint: ${path} · Showing ${Math.min(20, blocks.length)}`;

    $("blocksBody").innerHTML = blocks.slice(0,20).map(b => {
      const hash = b?.hash ?? b?.blockHash ?? b?.block_hash ?? b?.id ?? "—";
      const time = b?.timestamp ?? b?.time ?? b?.blockTime ?? b?.acceptedAt ?? b?.accepted_at ?? null;
      const score = b?.blueScore ?? b?.blue_score ?? b?.daaScore ?? b?.daa_score ?? b?.height ?? b?.blockHeight ?? b?.block_height ?? null;
      const txs = b?.txCount ?? b?.transactionCount ?? b?.transaction_count ?? (Array.isArray(b?.transactions) ? b.transactions.length : null);

      const hashCell = (hash && hash !== "—")
        ? `<a class="mono" href="${STREAM_BLOCK(hash)}" target="_blank" rel="noreferrer">${shortHash(hash, 22)}</a>`
        : `<span class="mono">—</span>`;

      return `<tr>
        <td class="nowrap">${fmtDate(time)}</td>
        <td>${hashCell}</td>
        <td class="nowrap">${score==null ? "—" : fmtNum(score,0)}</td>
        <td class="nowrap">${txs==null ? "—" : fmtNum(txs,0)}</td>
      </tr>`;
    }).join("");
  }

  // ====== TXS (INDEXER) ======
  async function loadTxs(){
    $("txErr").textContent = "";
    $("txMeta").textContent = "—";
    setLoading("txs");

    const found = await firstWorkingJson(INDEXER_BASE, [
      `/transactions?limit=20`,
      `/txs?limit=20`,
      `/txs`,
      `/transactions`,
    ]);

    if (!found){
      $("txBody").innerHTML = `<tr><td colspan="4" class="status">No transactions endpoint found.</td></tr>`;
      $("txErr").innerHTML = `<span class="bad">Indexer tx endpoint not found.</span>`;
      return;
    }

    const { path, data } = found;

    const txs = Array.isArray(data) ? data
      : Array.isArray(data?.transactions) ? data.transactions
      : Array.isArray(data?.items) ? data.items
      : [];

    if (!txs.length){
      $("txBody").innerHTML = `<tr><td colspan="4" class="status">No transactions returned.</td></tr>`;
      $("txMeta").textContent = `Endpoint: ${path}`;
      return;
    }

    $("txMeta").textContent = `Endpoint: ${path} · Showing ${Math.min(20, txs.length)}`;

    $("txBody").innerHTML = txs.slice(0,20).map(t => {
      const txid = t?.transactionId ?? t?.txid ?? t?.id ?? t?.hash ?? "—";
      const time = t?.blockTime ?? t?.timestamp ?? t?.time ?? t?.acceptedAt ?? t?.accepted_at ?? null;
      const vin = t?.inputs?.length ?? t?.vin?.length ?? t?.inputCount ?? t?.input_count ?? null;
      const vout = t?.outputs?.length ?? t?.vout?.length ?? t?.outputCount ?? t?.output_count ?? null;

      const txCell = (txid && txid !== "—")
        ? `<a class="mono" href="${STREAM_TX(txid)}" target="_blank" rel="noreferrer">${shortHash(txid, 26)}</a>`
        : `<span class="mono">—</span>`;

      return `<tr>
        <td class="nowrap">${fmtDate(time)}</td>
        <td>${txCell}</td>
        <td class="nowrap">${vin==null ? "—" : fmtNum(vin,0)}</td>
        <td class="nowrap">${vout==null ? "—" : fmtNum(vout,0)}</td>
      </tr>`;
    }).join("");
  }

  // ====== REFRESH LOOP (SMOOTH) ======
  let refreshing = false;

  async function refreshAll(){
    $("last").textContent = new Date().toLocaleTimeString();
    // Run in parallel; each section handles its own errors
    await Promise.allSettled([
      loadMarket(),
      loadNetwork(),
      loadBlocks(),
      loadTxs(),
    ]);
  }

  async function loop(){
    if (refreshing) return;
    refreshing = true;
    try{
      await refreshAll();
    } finally {
      refreshing = false;
      if ($("auto").checked){
        setTimeout(loop, REFRESH_MS);
      }
    }
  }

  $("refreshBtn").onclick = () => refreshAll();
  $("auto").onchange = () => { if ($("auto").checked) loop(); };

  // kick off
  loop();
</script>
</body>
</html>
